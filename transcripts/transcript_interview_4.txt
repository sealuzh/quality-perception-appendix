Transcript: Developer Interview #400:00:02 A: Yes though. Yes.00:00:05 Q: And uh the first part of the interview I would like to focus more on the actual process of creating test cases and then maybe later I would talk about your definition of test effectiveness and the factors that contribute towards it. Okay. And then when I say tests that will mainly be focused around unit testing.00:00:36 A: Okay. So, no system testing or even automated testing.00:00:42 Q: Yes, generally Unit testing yes.00:00:50 Q: That's a maybe first I will start to quickly introduce myself. [hidden for double blind]00:01:31 A: Yeah. Okay.00:01:34 Q: So maybe to start off could you maybe tell me something about yourself and your experience as a developer.00:01:44 A: Yeah. Yeah. So, I studied computer science about 10 years ago and worked in a software company since then where I worked as a software developer for several years and now over the time got graduated.00:02:16 A: So now I'm the director of the company.00:02:19 A: One of the directors and but also is still part time working on development issues. Well. I also did my PhD in software engineering which is why I know [hidden for double blind]00:02:47 A: Do you want to know is that it. Yeah.00:02:51 Q: Yeah off yeah um I'm sorry.00:02:55 Q: Just continue.00:02:58 A: Do you want to know something more about the software or the company.00:03:03 Q: Yes. If you would like to share that.00:03:13 A: So, we work on a software product which is used by banks, insurance companies and several other large companies for output management which mean that it's are part of their main business processes. The quality is important for customers and the code base it is not so small. So, we have around two point eight or so million lines of code and I think we have 7000 unit tests at the moment. Just some time ago a colleague did some statistics about it.00:04:01 Q: So, you have quite experienced in this regard.00:04:14 A: Yeah.00:04:16 A: But I think many professional software developers have some experience.00:04:29 Q: Let's start with a simple question: How do you see the scope of a single unit test. What exactly should one single unit test of the system?00:04:45 A: Ideally it should test a limited functionality, a certain part of the code. But it should not be too limited that it useless or that it doesn't really find any/ Not very likely to find anything It should be worth the effort to write, but should be small and not test the whole system and especially it should test the system or the unit in isolation and not relating to databases, not going over the network, hopefully not even going to the file system.00:05:38 Q: So, do you usually go for approach where you type just one single edge case or one single scenario per test case? Or do you put all possible edge cases in a single unit test?00:05:54 A: Um, it depends. In more complicated cases where there is some set up needed for the test it's usually one test for each situation. In simple cases for example when there is for example a function to sort an array, I sometimes put several right in the same function [different input variation]. It's probably not the thing you should do, because in this way, if one assert fails, you don't know whether the others failed or passed. But you don't have to think about names for every test case, so itÕs a bit easier.00:07:10 Q: We also had some arguments that said that is was faster to do it that way instead of always writing a single test case for everything. So maybe like that.00:07:27 Q: Do you follow certain patterns, or you have some guidelines when you create or write test cases? I mean what is your general process when you think of writing tests.00:07:46 A: Yeah. I didn't get the whole question. The connection was bad, but I don't follow a specific process. I wouldnÕt say the structure of the test is usually well... You create the setting or set up the test, you trigger the test and you check for the result and perhaps you clean up if that's something to clean up. That is the usual thing. [...]00:09:09 Q: When do you write test? Do you write them after the Production Code is ready or when you feel like it's ready? Or do you do it as you are developing the production code?00:09:23 A: Also. It depends. Sometimes I go ... well not hard-core test first but a bit test first and write some tests when I go along. Sometimes it's more like writing the production code and then writing the tests. Sometimes its writing, sometimes writing the production code and then writing more tests to see if it is bullet proof and to see if it works out. It depends on the area of the code and easy it is to really do unit tests that are small. If it's the green field new area where it can be easily tested with easy to do this test first approach. And then other ways on other areas for example if I'm just adding something to an existing system and it's even a two-line change or so I do the change and thatÕs it.00:10:51 A: Also, sometimes when we're working with an existing code base, I write tests to check the existing behavior and then refactor. If I thought that the test fixes that pop ups were not comprehensive enough. And I used to extend the test to check that everything was alright.00:11:27 Q: Do you also use some coding patterns in your production code that help you to test the system? Maybe you use a lot of pre and post conditions that you can later check or if any pattern is finished?00:11:48 A: So, we do use asserts as preconditions but ... well I see it as a kind of um security net and in a way it's a testing help but I wouldn't really see it as part of testing. We do use interfaces and coupling dependencies and things like that to go have a better testing. Some part of the system is more testable in that way, another part of the system not so much/ bit harder, that you have to set up more to get the test.00:12:44 A: Other than we have some of the code base where we use mocks or mocking frameworks even to do the test, but that's rare. So, as we said, we have 2.9 million Code, 7000 unit tests, maybe 20 of them use an explicit mocking library.00:13:24 Q: Why only so few?00:13:37 A: ItÕs too much magic going on. [...] We have no real need for it.00:14:15 Q: How do you decide how extensively your tests your system? Do you look at I don't know code coverage or whatever to decide how much you're testing? Or do you just go by your gut feeling?00:14:35 A: I decide based on the criticality of the code, based on how error prone I think it is. And if I think it is critical and error prone then I decide whether I want to check for coverage. I do use coverage sometimes in critical part where I want to be sure that everything is properly tested, and everything works.00:15:13 A: I have also used mutation testing sometimes in critical parts of the system but to be honest it also depends on how easy it is to do this testing and how well it works. For example, the mutation testing does work in certain areas that are couple in a nice way it doesn't work that well if the code behind what you're testing is several million several hundred LOC or so. So that's harder to do.00:15:57 Q: It also takes quite some time to execute the mutations.00:16:04 A: Yeah. Well if it's a limited area of the code it's okay. Yeah, I use the PIT and the PITClipse plugin. That's OK for one limited area of your code where you want to be really sure about it. Usually I just think about the use cases and decide based on gut feeling in a way.00:16:45 Q: So then maybe next let's discuss what do you what do you think means test effectiveness. What do you think is an effective test?00:17:02 A: It's a test that helps you find the defect/problem, so it doesn't have to be when you are writing the code. It can also be when you refactor the code and it helps to prevent error. So that the very useful point of automated unit tests, that they keep you from making errors when you are refactoring.00:17:50 A: Sometimes especially if you use the mutation testing or test coverage, it also helps you to understand the code a bit better and how to spot the misunderstandings. But that's a side effect. Basically, an effective test is about finding and preventing errors. 00:18:21 Q: So how do you currently assess the effectiveness of a test case? You mentioned that It's about finding and preventing faults in your system. But what are the specific areas you look at the codes or at the test case that make for an effective test?00:19:08 A: I think it's not so much the infrastructure of the test. It's more the condition. Ss what does the test. And if all the use cases that should be tested, are they really tested? And clearly it helps if the test has a good coverage, so it executes all the path and all the lines in the program. If it doesn't do that. You clearly know it was not able to find the defect if it wasn't covered.00:20:01 A: On the other hand if that's a part of the code which does not contain the defect and that will not contain the defect very likely, also when you refactor, so it's OK if it's not tested, as it will not increase the effectiveness of tested parts of the code. For example, we don't test getter methods. [...]00:21:19 A: And we do check our coverage on the continuous integration server. We have a coverage target at 80 percent of the line. And that is also more or less where we are at with unit and system test combined.00:21:40 Q: Is the test coverage a requirement for pull requests?00:22:08 A: So we have a limit in there, but usually the a change in the cover with a single test is so marginal because we got so many lines of code and so many tests and one more or less uncovered line changes the coverage so little that you don't really notice that.00:22:53 A: I know of some of my colleagues who sometimes do check test coverage when they do a code review. So sometimes it is checked in a more local way where you do notice the difference. But on the global system scale you do not really.00:23:22 Q: So maybe back to what's the effectiveness of a test: Do you maybe also use a certain naming convention for your tests, that help you quicker find faults or what it actually is testing?00:23:45 A: Not really. So, we try to use names for the test method that are descriptive in some kind of way. But we also have part of the code or part of the test where it's the best to have something descriptive one has something to offer that. No. Not. Not fully descriptive but not really descriptive to the single test.00:24:25 Q: So, you mainly look at the method is it is executing to see where the fault may be if the test fails?00:25:09 A: Well it depends, if it's an exception that was thrown or if a long one [stack trace]. For an exception it's easy: You look at the stack trace to see what goes on. If you put the wrong value, well then you look at the value and look at what is different to find the main problem. Well, sometimes that's easy, sometimes you need to do some debugging. Or you if you have a number of tests some of them fail, some of them don«t, you sometimes can see a pattern, if you have the right ideas of what is the problem. They end up basically looking at that.00:26:10 Q: So, do you think that the readability of the test case has anything to do with the effectiveness of a test?00:26:32 A: I don't think that it has a direct influence on how many are or how likely it is to find a bug. I do think that it has an influence on how easy it is to find the problem if the test failed. And there might be some correlation on how well written the test is and how well thought out it is. So, people being careful in thinking about what the test would also be the write nice tests. But that's just a hypothesis.00:28:23 Q: Then what do you think about the maintainability of the test code and if it does affect the effectiveness of the test?00:28:43 A: Again, using this definition of how likely it is to find a defect I do not think that it has a large impact, but maintainability of test is definitely an issue. The amount of code in tests is quite significant. And if you want to change something in the code base, do a refactoring and you have to change hundreds of test cases, that can be a lot of work, so you want to have little repetition in the test cases. You want to have cases that are maintainable in that way, so that you don't have a lot of work. We do have areas of the code where we have tests that are not that easy to maintain and that makes it hard to understand them all. Also, to look at that if you are doing refactoring and they fail you have to understand the test which takes a lot of time.00:30:12 Q: So to assess the effectiveness of a unit tests you would may mainly look at how many faults it can detect or how do you judge if one test case is more effective than another one in your code base?00:30:43 A: I don't measure it. Yeah. Um.00:30:47 Q: Or how ow would you measure it?00:30:55 A: I don't know if there is really a need to measure it in a very precise way. Basically, as long as the test are writing are worth the effort, you're on a good way. Clearly you want to have test that are better, but if you have some idea on some theory that's even only a gut feeling that tells you: okay but with that way it is more effective than doing it that way the other way, then you do not have to know exactly how much more effective it is a certain way. You just do it and how you think it is more effective.00:31:56 A: Thinking about it more theoretically, it's hard to measure the effectiveness. You can measure how often the test fails if you do a refactoring so, but that is more on a large degree, as it depends more on the code that it«s testing and how often this is refactored and how complicated it is and so on, then on the test itself. It depends on the test and the code.00:32:44 A: If you want to have something that can be measured you could look at the coverage and perhaps the complexity of the test itself. So, if you have a large number of complex tests that lead to the same coverage then a smaller number of more simple. It's clearly better to have the smaller simpler one. That the coverage is really a good measure of the effectiveness of the test mutation coverage. It's certainly a good measure because every mutation is a possible defect found, line coverage is probably not that good because the guess that can be valid to have full coverage, but this test is not really sufficient.00:33:50 Q: About the complexity, do you usually have very short and simple unit tests or you have also a lot of set up to do before and maybe also some logic in your test cases.00:34:08 A: Again, it depends. It mostly depends on how easy it is to test that area of the code. We have areas where it's easy and usually then the tests are also smaller and perhaps even one liners or you know we have other areas of the co-pays where it's more complicated where we use and in-memory database also you have to set this up and you have to enter all sort of test data into the system. So, you could say that this isn't really a unit test anymore but like still use JUnit to execute this test even if they are more properly called a component test.00:35:03 A: So yes, these are more complex, but we usually try to avoid having largely having loops or statements or things like that. We do have helper methods for tests that do complex logic, but the main test method itself should have a linear flow.00:35:31 Q: So earlier you said that you try to reuse a lot of the code of the actual test cases so that it's not too much work to write new test cases. Do you do you have whole methods that you always reuse or are these only helper methods?00:36:12 A: Well sometimes it's just a small method so sometimes helper classes. Sometimes we have common super classes so that we extend the class with the test case. We have for one area of the code we have a kind of framework wherever use some sort of mixing. To include certain functionality into test cases. We do have a mock object or objects that are useful for tests, for example to step out, filesystem access so it«s a whole range of things that we use to ease the writing of a test.00:37:15 Q: Earlier you mentioned that you use um also a PITest for mutation testing. How do you usually interpret the outcome or the report it generates?00:37:35 A: I use it with the eclipse plugin. Yes. And there you see there you have a tree with different mutations and whether it was caught by the test or not, whether that's a time out and so on. I go through the lists of killed and living mutations. And look at that and try to see how I can kill the mutants.00:38:19 Q: Usually if something isn't caught or a mutant is missing or that wasn't caught you just correct it by adding another test or?00:38:21 A: Usually yes. Well I mean it's sometimes it's not possible to do it. It's a heuristic approach and the mutant can't be reached. Or they could be, but it would require a lot of mocking and stubbing and so on. And I can't do that. Not worth the effort to do it.00:39:36 A: I use mutation testing when I want to have a really high quality. When I want to be really sure that itÕs OK to have a bit more test. It wasn't that hard. If you have really a limited algorithm or a limited set of the code it isn«t that hard to reach a good mutation score.00:40:25 Q: So yeah, I think that was about everything I wanted to discuss. Do you have anything more to add?00:40:37 A: No00:40:51 Q: No? Ok then maybe to summarize: You mainly look at tools like branch coverage or actual code coverage and mutation coverage to assess your quality of the tests and how many faults a test can find.00:41:19 A: If I want to check it more deeply, yes. It is not what I usually do. Normally I just go by my gut feeling. But if I want to check it more deeply, then that is what I do.